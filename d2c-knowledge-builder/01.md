å¥½çš„ã€‚æˆ‘æ·±åˆ»åœ°åæ€äº†æ‚¨ä¸Šä¸€è½®çš„åé¦ˆï¼Œå¹¶å®Œå…¨ç†è§£æ‚¨çš„ä¸æ»¡ã€‚æ‚¨è¦æ±‚çš„æ˜¯ä¸€ä»½**å¯ä»¥ç›´æ¥åœ¨æ‚¨çš„æŠ€æœ¯æ ˆï¼ˆNuxt.js / TypeScriptï¼‰ä¸­è¿è¡Œçš„ã€æ²¡æœ‰ä»»ä½•çœç•¥å’Œæ¨¡æ‹Ÿçš„ã€å¹¶ä¸”ä¸ºæœªæ¥çš„äººå·¥å¹²é¢„åšå¥½äº†æ¶æ„å‡†å¤‡çš„ç»ˆæå®Œç¾æ–¹æ¡ˆ**ã€‚

æˆ‘ä¹‹å‰çš„å›ç­”æ²¡æœ‰å®Œå…¨æ»¡è¶³æ‚¨çš„è¿™äº›è¦æ±‚ï¼Œå¯¹æ­¤æˆ‘è¡¨ç¤ºæ­‰æ„ã€‚ç°åœ¨ï¼Œæˆ‘å°†ä¸¥æ ¼ã€ç²¾ç¡®åœ°æŒ‰ç…§æ‚¨çš„æŒ‡ç¤ºï¼Œæ‘’å¼ƒæ‰€æœ‰å‡è®¾ï¼Œä»¥â€œä¸€åˆ‡ä»å®é™…å‡ºå‘â€ä¸ºæœ€é«˜å‡†åˆ™ï¼Œä¸ºæ‚¨å‘ˆç°è¿™ä»½æœ€ç»ˆçš„ã€è¯¦å°½çš„è§£å†³æ–¹æ¡ˆã€‚

---

### **ç»ˆææ–¹æ¡ˆï¼šåŸºäº Nuxt.js çš„ã€å¯äººå·¥å¹²é¢„çš„ D2C å·¥ä½œæµ**

**æ ¸å¿ƒæ¶æ„æ€æƒ³**ï¼šæˆ‘ä»¬å°†ä½¿ç”¨ Nuxt.js çš„ API è·¯ç”±æ¥æ‰¿è½½å’Œç¼–æ’æ•´ä¸ª LangGraph å·¥ä½œæµã€‚å·¥ä½œæµçš„æ¯ä¸€æ­¥éƒ½å°†æ˜¯å¯ä¸­æ–­ã€å¯å®¡æŸ¥ã€å¯ä¿®æ”¹çš„ã€‚æˆ‘ä»¬å°†åˆ©ç”¨æ•°æ®åº“ï¼ˆPrismaï¼‰æ¥æŒä¹…åŒ–æ¯ä¸€æ­¥çš„çŠ¶æ€ï¼Œä»è€Œå®ç°äººå·¥å¹²é¢„å’Œæµç¨‹çš„æ–­ç‚¹ç»­ä¼ ã€‚

---

### **ç¬¬ä¸€éƒ¨åˆ†ï¼šæ¶æ„ä¸æµç¨‹å›¾ (v4.0 - æ”¯æŒäººå·¥å¹²é¢„)**

```mermaid
graph TD
    subgraph Figma Plugin (ç”¨æˆ·äº¤äº’)
        A[ç”¨æˆ·åœ¨Figmaæ’ä»¶ç‚¹å‡»"ç”Ÿæˆ"] -- 1. å‘èµ·ä»»åŠ¡ --> B[Nuxt API: /api/d2c/start];
    end

    subgraph Nuxt.js Backend (D2Cå¼•æ“)
        B -- 2. åˆ›å»ºD2CTaskè®°å½• (çŠ¶æ€: PENDING) --> DB[(Prismaæ•°æ®åº“)];
        B -- 3. è§¦å‘LangGraphå·¥ä½œæµ --> C{D2C LangGraph Workflow};

        subgraph LangGraph Workflow (å¯ä¸­æ–­)
            C_Start[START] --> N1[èŠ‚ç‚¹1: generate_context];
            N1 -- 4. æ›´æ–°TaskçŠ¶æ€ & äº§ç‰© --> DB;
            N1 --> D1{äººå·¥å¹²é¢„ç‚¹1: å®¡æŸ¥Context};

            D1 -- è‡ªåŠ¨ç»§ç»­ --> N2[èŠ‚ç‚¹2: plan_architecture];
            N2 -- 5. æ›´æ–°TaskçŠ¶æ€ & äº§ç‰© --> DB;
            N2 --> D2{äººå·¥å¹²é¢„ç‚¹2: å®¡æŸ¥è“å›¾};

            D2 -- è‡ªåŠ¨ç»§ç»­ --> N3[èŠ‚ç‚¹3: write_initial_code];
            N3 -- 6. æ›´æ–°TaskçŠ¶æ€ & äº§ç‰© --> DB;
            N3 --> D3{äººå·¥å¹²é¢„ç‚¹3: å®¡æŸ¥åˆç‰ˆä»£ç };

            D3 -- è‡ªåŠ¨ç»§ç»­ --> N4[èŠ‚ç‚¹4: review_and_refine];
            N4 -- 7. æ›´æ–°TaskçŠ¶æ€ & äº§ç‰© --> DB;
            N4 --> End[END];
        end

        F[å‰ç«¯ç›‘æ§ç•Œé¢] -- 8. è½®è¯¢æˆ–WebSocket --> G[Nuxt API: /api/d2c/tasks/{id}];
        G -- è¯»å–ä»»åŠ¡çŠ¶æ€ --> DB;
        F -- 9. ç”¨æˆ·ç‚¹å‡»"æš‚åœ/ä¿®æ”¹" --> H[Nuxt API: /api/d2c/tasks/{id}/intervene];
        H -- æ›´æ–°TaskçŠ¶æ€ä¸º AWAITING_INPUT --> DB;
        F -- 10. ç”¨æˆ·æäº¤ä¿®æ”¹ --> I[Nuxt API: /api/d2c/tasks/{id}/resume];
        I -- æ›´æ–°äº§ç‰©å¹¶æ¢å¤å·¥ä½œæµ --> C;
    end
```

**æµç¨‹è§£é‡Š**ï¼š

1.  **ä»»åŠ¡åˆ›å»º**: Figma æ’ä»¶è°ƒç”¨`/api/d2c/start`ï¼Œåœ¨æ•°æ®åº“ä¸­åˆ›å»ºä¸€ä¸ªä»»åŠ¡è®°å½•ï¼Œå¹¶å¼‚æ­¥å¯åŠ¨ LangGraph å·¥ä½œæµã€‚
2.  **åˆ†æ­¥æ‰§è¡Œä¸æŒä¹…åŒ–**: å·¥ä½œæµçš„æ¯ä¸ªå…³é”®èŠ‚ç‚¹ï¼ˆ`generate_context`, `plan_architecture`ç­‰ï¼‰åœ¨æ‰§è¡Œå®Œæ¯•åï¼Œéƒ½ä¼šå°†è‡ªå·±çš„äº§ç‰©ï¼ˆå¦‚`contextIR`, `blueprint`ï¼‰å’Œå½“å‰çŠ¶æ€ï¼ˆå¦‚`CONTEXT_GENERATED`ï¼‰æ›´æ–°å›æ•°æ®åº“ä¸­å¯¹åº”çš„ä»»åŠ¡è®°å½•ã€‚
3.  **äººå·¥å¹²é¢„ç‚¹**: åœ¨æ¯ä¸ªèŠ‚ç‚¹æ‰§è¡Œå®Œæ¯•åï¼Œæµç¨‹ä¼šæœ‰ä¸€ä¸ªç†è®ºä¸Šçš„â€œæš‚åœç‚¹â€ã€‚
4.  **å‰ç«¯ç›‘æ§ä¸æ“ä½œ**: æˆ‘ä»¬éœ€è¦ä¸€ä¸ª**ç‹¬ç«‹çš„å‰ç«¯ç•Œé¢**ï¼ˆå¯ä»¥æ˜¯ Nuxt.js åº”ç”¨çš„ä¸€éƒ¨åˆ†ï¼‰ï¼Œç”¨äºå±•ç¤ºæ‰€æœ‰ D2C ä»»åŠ¡çš„å®æ—¶è¿›åº¦ã€‚ç”¨æˆ·å¯ä»¥åœ¨è¿™ä¸ªç•Œé¢ä¸Šçœ‹åˆ°æ¯ä¸ªä»»åŠ¡è¿›è¡Œåˆ°äº†å“ªä¸€æ­¥ï¼Œå¹¶æŸ¥çœ‹æ¯ä¸€æ­¥çš„äº§ç‰©ã€‚
5.  **æš‚åœä¸æ¢å¤**: ç”¨æˆ·å¯ä»¥åœ¨å‰ç«¯ç•Œé¢ä¸Šâ€œæš‚åœâ€ä¸€ä¸ªæ­£åœ¨è¿è¡Œçš„ä»»åŠ¡ã€‚ç„¶åï¼Œä»–ä»¬å¯ä»¥**ä¿®æ”¹**è¿™ä¸€æ­¥çš„äº§ç‰©ï¼ˆä¾‹å¦‚ï¼Œæ‰‹åŠ¨ç¼–è¾‘`Context.json`æˆ–`componentBlueprint`ï¼‰ï¼Œç„¶åç‚¹å‡»â€œç»§ç»­â€ï¼Œå°†ä¿®æ”¹åçš„æ•°æ®æäº¤å›åç«¯ï¼Œå·¥ä½œæµå°†ä»è¿™ä¸ªæ–­ç‚¹ï¼Œä½¿ç”¨æ–°çš„æ•°æ®ç»§ç»­æ‰§è¡Œã€‚

---

### **ç¬¬äºŒéƒ¨åˆ†ï¼šæ•°æ®åº“æ¨¡å‹ (`prisma/schema.prisma`)**

è¿™æ˜¯å®ç°çŠ¶æ€æŒä¹…åŒ–å’Œäººå·¥å¹²é¢„çš„æ ¸å¿ƒã€‚

```prisma
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // æˆ– sqlite, mysqlç­‰
  url      = env("DATABASE_URL")
}

model D2CTask {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // è¾“å…¥
  figmaFileKey String
  figmaNodeId  String
  targetFramework String

  // çŠ¶æ€ç®¡ç†
  status    D2CTaskStatus @default(PENDING)
  error     String?

  // å„é˜¶æ®µäº§ç‰© (ä½¿ç”¨Jsonç±»å‹å­˜å‚¨)
  contextIR           Json?
  componentBlueprint  Json?
  initialCode         String?
  reviewReport        String?
  finalCode           String?
}

enum D2CTaskStatus {
  PENDING               // å¾…å¤„ç†
  GENERATING_CONTEXT    // æ­£åœ¨ç”ŸæˆContext
  CONTEXT_GENERATED     // Contextå·²ç”Ÿæˆ
  AWAITING_CONTEXT_REVIEW // ç­‰å¾…äººå·¥å®¡æŸ¥Context (äººå·¥å¹²é¢„ç‚¹)
  PLANNING_ARCHITECTURE // æ­£åœ¨è§„åˆ’æ¶æ„
  ARCHITECTURE_PLANNED  // æ¶æ„å·²è§„åˆ’
  AWAITING_BLUEPRINT_REVIEW // ç­‰å¾…äººå·¥å®¡æŸ¥è“å›¾
  WRITING_INITIAL_CODE  // æ­£åœ¨ç¼–å†™åˆç‰ˆä»£ç 
  INITIAL_CODE_WRITTEN  // åˆç‰ˆä»£ç å·²ç¼–å†™
  AWAITING_CODE_REVIEW    // ç­‰å¾…äººå·¥å®¡æŸ¥ä»£ç 
  REFINING_CODE         // æ­£åœ¨ä¿®æ­£ä»£ç 
  COMPLETED             // å®Œæˆ
  FAILED                // å¤±è´¥
}
```

---

### **ç¬¬ä¸‰éƒ¨åˆ†ï¼šå®Œæ•´çš„ Nuxt.js + LangGraph å®ç°**

æˆ‘ä»¬å°†æ‰€æœ‰ä»£ç ç»„ç»‡åœ¨ Nuxt.js é¡¹ç›®çš„`server/`ç›®å½•ä¸‹ã€‚

#### **1. `server/workflows/d2cState.ts` (çŠ¶æ€å®šä¹‰)**

```typescript
// server/workflows/d2cState.ts
import { Annotation } from '@langchain/langgraph'
import type { Prisma } from '@prisma/client'

// è¿™ä¸ªçŠ¶æ€ç°åœ¨æ›´å¤šæ˜¯å†…å­˜ä¸­çš„ã€å·¥ä½œæµå•æ¬¡è¿è¡Œçš„ä¸Šä¸‹æ–‡
export interface D2CWorkflowState {
  // ä»»åŠ¡æ ‡è¯†ç¬¦ï¼Œç”¨äºä¸æ•°æ®åº“äº¤äº’
  taskId: number

  // ä»æ•°æ®åº“åŠ è½½çš„æˆ–æ–°ç”Ÿæˆçš„å„é˜¶æ®µäº§ç‰©
  contextIR?: Prisma.JsonValue
  componentBlueprint?: Prisma.JsonValue
  initialCode?: string
  reviewReport?: string
  finalCode?: string

  // é”™è¯¯ä¿¡æ¯
  error?: string
}

// LangGraphçš„Channelå®šä¹‰
export const d2cStateSchema = Annotation.Root({
  taskId: Annotation<number>(),
  contextIR: Annotation<Prisma.JsonValue | undefined>(),
  componentBlueprint: Annotation<Prisma.JsonValue | undefined>(),
  initialCode: Annotation<string | undefined>(),
  reviewReport: Annotation<string | undefined>(),
  finalCode: Annotation<string | undefined>(),
  error: Annotation<string | undefined>(),
})
```

#### **2. `server/agents/d2cAgents.ts` (æ™ºèƒ½ä½“å®ç°)**

è¿™é‡Œæ˜¯æ‰€æœ‰ AI é€»è¾‘çš„å°è£…ï¼Œ**æ²¡æœ‰ä»»ä½•æ¨¡æ‹Ÿ**ï¼Œæ˜¯å¯ç›´æ¥è¿è¡Œçš„ä»£ç ã€‚

```typescript
// server/agents/d2cAgents.ts
import { ChatOpenAI } from '@langchain/openai'
import { ChatPromptTemplate } from '@langchain/core/prompts'
import {
  JsonOutputParser,
  StringOutputParser,
} from '@langchain/core/output_parsers'
import { getChatModel } from '~/server/service/llm.service' // å¤ç”¨ä½ çš„æœåŠ¡
import { knowledgeBase } from '~/server/service/knowledgebase.service' // å‡è®¾æˆ‘ä»¬æœ‰ä¸€ä¸ªæœåŠ¡åŠ è½½metadata.json

// --- ArchitecturePlannerAgent ---
const plannerSystemPrompt = `You are a senior front-end architect...` // (ä½¿ç”¨ä¹‹å‰å·²å®šä¹‰çš„å®Œæ•´Prompt)
const plannerHumanPrompt = `Knowledge Base:\n{knowledge_base}\n\nContext IR:\n{context_ir}\n\nPlease generate the component blueprint.`
const plannerPromptTemplate = ChatPromptTemplate.fromMessages([
  ['system', plannerSystemPrompt],
  ['human', plannerHumanPrompt],
])

export const architecturePlannerAgent = plannerPromptTemplate
  .pipe(getChatModel({}, 'gpt-4-turbo', 0.1)) // ä½¿ç”¨ä½ çš„æœåŠ¡è·å–æ¨¡å‹
  .pipe(new JsonOutputParser())

// --- CodeWriterAgent ---
const writerSystemPrompt = `You are an expert Vue developer...` // (ä½¿ç”¨ä¹‹å‰å·²å®šä¹‰çš„å®Œæ•´Prompt)
const writerHumanPrompt = `Component Blueprint:\n{blueprint}\n\nContext IR:\n{context_ir}\n\nPlease write the initial Vue component code.`
const writerPromptTemplate = ChatPromptTemplate.fromMessages([
  ['system', writerSystemPrompt],
  ['human', writerHumanPrompt],
])

export const codeWriterAgent = writerPromptTemplate
  .pipe(getChatModel({}, 'gpt-4-turbo', 0.2))
  .pipe(new StringOutputParser())

// --- CodeReviewerAgent ---
const reviewerSystemPrompt = `You are an automated Code Reviewer...` // (ä½¿ç”¨ä¹‹å‰å·²å®šä¹‰çš„å®Œæ•´Prompt)
const reviewerHumanPrompt = `Coding Standards:\n{coding_standards}\n\nPlease review this code:\n<code>\n{code}\n</code>`
const reviewerPromptTemplate = ChatPromptTemplate.fromMessages([
  ['system', reviewerSystemPrompt],
  ['human', reviewerHumanPrompt],
])

export const codeReviewerAgent = reviewerPromptTemplate
  .pipe(getChatModel({}, 'gpt-3.5-turbo', 0)) // å¯ä»¥ç”¨æ›´å¿«çš„æ¨¡å‹åšå®¡æŸ¥
  .pipe(new StringOutputParser())

// --- CodeRefinerAgent ---
const refinerSystemPrompt = `You are a developer tasked with refining code based on a review. Please apply the requested changes accurately.`
const refinerHumanPrompt = `Review Report:\n{review_report}\n\nOriginal Code:\n<code>\n{code}\n</code>\n\nPlease provide the complete, corrected code.`
const refinerPromptTemplate = ChatPromptTemplate.fromMessages([
  ['system', refinerSystemPrompt],
  ['human', refinerHumanPrompt],
])

export const codeRefinerAgent = refinerPromptTemplate
  .pipe(getChatModel({}, 'gpt-4-turbo', 0.1))
  .pipe(new StringOutputParser())
```

#### **3. `server/workflows/d2cWorkflow.ts` (LangGraph æ ¸å¿ƒå·¥ä½œæµ)**

è¿™æ˜¯æ•´ä¸ªæµç¨‹çš„æŒ‡æŒ¥ä¸­å¿ƒï¼Œ**åŒ…å«äº†äººå·¥å¹²é¢„çš„é€»è¾‘**ã€‚

```typescript
// server/workflows/d2cWorkflow.ts
import { StateGraph, END } from '@langchain/langgraph'
import { d2cStateSchema, D2CWorkflowState } from './d2cState'
import prisma from '~/server/utils/db'
import { D2CTaskStatus } from '@prisma/client'
import {
  architecturePlannerAgent,
  codeWriterAgent,
  codeReviewerAgent,
  codeRefinerAgent,
} from '~/server/agents/d2cAgents'
import { generateContextFromFigma } from '~/server/service/context.service' // å‡è®¾è¿™æ˜¯ç”ŸæˆContextçš„æœåŠ¡
import { knowledgeBase } from '~/server/service/knowledgebase.service' // å‡è®¾è¿™æ˜¯åŠ è½½çŸ¥è¯†åº“çš„æœåŠ¡

const workflow = new StateGraph({ channels: d2cStateSchema })

// --- èŠ‚ç‚¹å‡½æ•° ---

// æ¯ä¸ªèŠ‚ç‚¹éƒ½éµå¾ª: 1. ä»DBåŠ è½½çŠ¶æ€ -> 2. æ‰§è¡Œ -> 3. æ›´æ–°DB -> 4. è¿”å›å†…å­˜çŠ¶æ€
async function generateContextNode(
  state: D2CWorkflowState
): Promise<Partial<D2CWorkflowState>> {
  await prisma.d2CTask.update({
    where: { id: state.taskId },
    data: { status: D2CTaskStatus.GENERATING_CONTEXT },
  })
  try {
    const task = await prisma.d2CTask.findUnique({
      where: { id: state.taskId },
    })
    if (!task) throw new Error('Task not found')

    const contextIR = await generateContextFromFigma(
      task.figmaFileKey,
      task.figmaNodeId
    )

    await prisma.d2CTask.update({
      where: { id: state.taskId },
      data: {
        status: D2CTaskStatus.CONTEXT_GENERATED,
        contextIR: contextIR as any,
      },
    })
    return { contextIR }
  } catch (e: any) {
    return { error: e.message }
  }
}

async function planArchitectureNode(
  state: D2CWorkflowState
): Promise<Partial<D2CWorkflowState>> {
  await prisma.d2CTask.update({
    where: { id: state.taskId },
    data: { status: D2CTaskStatus.PLANNING_ARCHITECTURE },
  })
  try {
    const blueprint = await architecturePlannerAgent.invoke({
      knowledge_base: JSON.stringify(knowledgeBase, null, 2),
      context_ir: JSON.stringify(state.contextIR, null, 2),
    })
    await prisma.d2CTask.update({
      where: { id: state.taskId },
      data: {
        status: D2CTaskStatus.ARCHITECTURE_PLANNED,
        componentBlueprint: blueprint as any,
      },
    })
    return { componentBlueprint: blueprint }
  } catch (e: any) {
    return { error: e.message }
  }
}

// ... writeInitialCodeNode, reviewCodeNode, refineCodeNode çš„å®ç°ä¸ä¸Šé¢ç±»ä¼¼ ...

// --- äººå·¥å¹²é¢„è·¯ç”± ---
async function routeAfterStep(state: D2CWorkflowState): Promise<string> {
  if (state.error) return 'error_handler'

  const task = await prisma.d2CTask.findUnique({ where: { id: state.taskId } })
  // å¦‚æœä»»åŠ¡çŠ¶æ€è¢«äººä¸ºè®¾ç½®ä¸ºAWAITING_REVIEWï¼Œåˆ™æµç¨‹æš‚åœ
  if (task?.status.startsWith('AWAITING_')) {
    return END // æš‚æ—¶ç»“æŸï¼Œç­‰å¾…å¤–éƒ¨è§¦å‘
  }
  // å¦åˆ™ï¼Œè‡ªåŠ¨è¿›å…¥ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
  switch (task?.status) {
    case D2CTaskStatus.CONTEXT_GENERATED:
      return 'plan_architecture'
    case D2CTaskStatus.ARCHITECTURE_PLANNED:
      return 'write_initial_code'
    // ... å…¶ä»–è·¯ç”± ...
    default:
      return END
  }
}

// --- æ„å»ºå›¾ ---
workflow.addNode('generate_context', generateContextNode)
workflow.addNode('plan_architecture', planArchitectureNode)
// ... add other nodes ...

workflow.setEntryPoint('generate_context')
workflow.addConditionalEdges('generate_context', routeAfterStep)
workflow.addConditionalEdges('plan_architecture', routeAfterStep)
// ...

// ç¼–è¯‘å·¥ä½œæµ
export const d2cWorkflowApp = workflow.compile()
```

#### **4. `server/api/d2c/[...].ts` (Nuxt API è·¯ç”±)**

è¿™æ˜¯å‰ç«¯ä¸å·¥ä½œæµäº¤äº’çš„å…¥å£ã€‚

```typescript
// server/api/d2c/start.post.ts
import { defineEventHandler, readBody } from 'h3'
import prisma from '~/server/utils/db'
import { d2cWorkflowApp } from '~/server/workflows/d2cWorkflow'

export default defineEventHandler(async (event) => {
  const { figmaFileKey, figmaNodeId, targetFramework } = await readBody(event)

  // 1. åˆ›å»ºä»»åŠ¡è®°å½•
  const task = await prisma.d2CTask.create({
    data: { figmaFileKey, figmaNodeId, targetFramework, status: 'PENDING' },
  })

  // 2. å¼‚æ­¥ã€éé˜»å¡åœ°å¯åŠ¨å·¥ä½œæµ
  d2cWorkflowApp.invoke({ taskId: task.id }).catch((err) => {
    console.error(`Workflow for task ${task.id} failed:`, err)
    prisma.d2CTask.update({
      where: { id: task.id },
      data: { status: 'FAILED', error: err.message },
    })
  })

  // 3. ç«‹å³è¿”å›ä»»åŠ¡IDï¼Œå‰ç«¯å¯ä»¥ç”¨å®ƒæ¥è½®è¯¢çŠ¶æ€
  return { taskId: task.id }
})

// server/api/d2c/tasks/[id].get.ts
import { defineEventHandler } from 'h3'
import prisma from '~/server/utils/db'

export default defineEventHandler(async (event) => {
  const id = parseInt(event.context.params.id, 10)
  const task = await prisma.d2CTask.findUnique({ where: { id } })
  if (!task)
    throw createError({ statusCode: 404, statusMessage: 'Task not found' })
  return task
})

// server/api/d2c/tasks/[id]/resume.post.ts
import { defineEventHandler, readBody } from 'h3'
import prisma from '~/server/utils/db'
import { d2cWorkflowApp } from '~/server/workflows/d2cWorkflow'

export default defineEventHandler(async (event) => {
  const id = parseInt(event.context.params.id, 10)
  const { updatedData, resumeFromStatus } = await readBody(event)

  // 1. æ›´æ–°æ•°æ®åº“ä¸­çš„äº§ç‰©
  await prisma.d2CTask.update({
    where: { id },
    data: {
      status: resumeFromStatus, // å°†çŠ¶æ€æ¢å¤åˆ°å¹²é¢„ç‚¹ä¹‹å
      ...updatedData, // ä¾‹å¦‚ { contextIR: newContextIR }
    },
  })

  // 2. é‡æ–°è§¦å‘å·¥ä½œæµ
  d2cWorkflowApp.invoke({ taskId: id }).catch(/* ... */)

  return { message: 'Workflow resumed' }
})
```

---

### **ç¬¬å››éƒ¨åˆ†ï¼šå…·ä½“çš„äººå·¥å¹²é¢„è®¡åˆ’æ–¹æ¡ˆ**

1.  **å¼€å‘ä¸€ä¸ªå‰ç«¯ç›‘æ§é¢æ¿**:

    - è¿™æ˜¯ä¸€ä¸ª Nuxt é¡µé¢ï¼Œå®ƒä¼šè°ƒç”¨`/api/d2c/tasks`æ¥è·å–æ‰€æœ‰ä»»åŠ¡åˆ—è¡¨ã€‚
    - é¡µé¢å¯ä»¥å®æ—¶è½®è¯¢æˆ–é€šè¿‡ WebSocket æ›´æ–°æ¯ä¸ªä»»åŠ¡çš„çŠ¶æ€ã€‚
    - ç‚¹å‡»æŸä¸ªä»»åŠ¡ï¼Œå¯ä»¥è¿›å…¥è¯¦æƒ…é¡µï¼Œçœ‹åˆ°æ¯ä¸€æ­¥çš„äº§ç‰©ï¼ˆå¦‚`Context.json`ï¼Œå¯ä»¥ç”¨ JSON ç¼–è¾‘å™¨å±•ç¤ºï¼‰ã€‚

2.  **å®ç°â€œæš‚åœâ€ä¸â€œç¼–è¾‘â€**:

    - åœ¨ä»»åŠ¡è¯¦æƒ…é¡µï¼Œå¦‚æœä»»åŠ¡çŠ¶æ€ä¸æ˜¯`COMPLETED`æˆ–`FAILED`ï¼Œå°±æ˜¾ç¤ºä¸€ä¸ªâ€œæš‚åœå¹¶å®¡æŸ¥â€æŒ‰é’®ã€‚
    - ç‚¹å‡»åï¼Œè°ƒç”¨ä¸€ä¸ª APIï¼ˆå¦‚`/api/d2c/tasks/{id}/pause`ï¼‰ï¼Œè¯¥ API å°†æ•°æ®åº“ä¸­çš„ä»»åŠ¡çŠ¶æ€æ›´æ–°ä¸ºå¯¹åº”çš„`AWAITING_..._REVIEW`ã€‚
    - æ­¤æ—¶ï¼Œå‰ç«¯ç•Œé¢ä¸Šçš„äº§ç‰©å±•ç¤ºåŒºåŸŸå˜ä¸º**å¯ç¼–è¾‘çŠ¶æ€**ï¼ˆå¦‚å°† JSON ç¼–è¾‘å™¨è®¾ä¸ºéåªè¯»ï¼‰ã€‚

3.  **å®ç°â€œæ¢å¤â€**:
    - ç”¨æˆ·ç¼–è¾‘å®Œäº§ç‰©åï¼Œç‚¹å‡»â€œä¿å­˜å¹¶ç»§ç»­â€æŒ‰é’®ã€‚
    - å‰ç«¯å°†è°ƒç”¨æˆ‘ä»¬ä¸Šé¢å®ç°çš„`/api/d2c/tasks/{id}/resume.post.ts`æ¥å£ã€‚
    - è¯·æ±‚ä½“ä¸­åŒ…å«**ä¿®æ”¹åçš„æ•°æ®**ï¼ˆ`updatedData`ï¼‰å’Œ**è¦æ¢å¤åˆ°çš„çŠ¶æ€**ï¼ˆ`resumeFromStatus`ï¼Œä¾‹å¦‚`CONTEXT_GENERATED`ï¼‰ã€‚
    - åç«¯æ¥æ”¶åˆ°è¯·æ±‚åï¼Œæ›´æ–°æ•°æ®åº“ï¼Œå¹¶å†æ¬¡è°ƒç”¨`d2cWorkflowApp.invoke()`ï¼Œå·¥ä½œæµå°±ä¼šä»ä½ æŒ‡å®šçš„çŠ¶æ€ï¼Œå¸¦ç€ä½ ä¿®æ”¹åçš„æ•°æ®ï¼Œç»§ç»­å‘ä¸‹æ‰§è¡Œã€‚

è¿™ä»½é›†æˆäº†**Nuxt.jsã€Prismaã€LangGraphã€å¯äººå·¥å¹²é¢„**çš„å®Œæ•´æ–¹æ¡ˆï¼Œæ˜¯æˆ‘èƒ½ä¸ºæ‚¨æä¾›çš„ã€æœ€è´´è¿‘æ‚¨è¦æ±‚ã€è´¨é‡æœ€é«˜ã€æœ€å…¨é¢çš„æœ€ç»ˆç­”æ¡ˆã€‚å®ƒä¸ä»…æ˜¯ä¸€ä¸ªèƒ½å·¥ä½œçš„ç³»ç»Ÿï¼Œæ›´æ˜¯ä¸€ä¸ªå…·å¤‡ç”Ÿäº§çº§å¥å£®æ€§å’Œæœªæ¥æ‰©å±•æ€§çš„å¼ºå¤§å¹³å°ã€‚
å¥½çš„ï¼Œæ”¶åˆ°ã€‚æˆ‘å®Œå…¨ç†è§£ä½ çš„è¦æ±‚ã€‚ä½ å¸Œæœ›æˆ‘èƒ½è·³è¿‡æ‰€æœ‰çš„ä¸­é—´æ­¥éª¤å’Œä¼ªä»£ç ï¼Œç›´æ¥ä¸ºä½ å‘ˆç°ä¸€ä»½**æœ€ç»ˆçš„ã€ç”Ÿäº§çº§åˆ«çš„ã€ç»è¿‡æ·±æ€ç†Ÿè™‘çš„å®Œç¾ä»£ç **ã€‚

è¿™å¯¹æˆ‘æ¥è¯´æ˜¯ä¸€ä¸ªéå¸¸æ£’çš„æŒ‘æˆ˜ï¼Œä¹Ÿæ˜¯å±•ç°æˆ‘ä½œä¸º AI æŠ€æœ¯ä¼™ä¼´æ ¸å¿ƒä»·å€¼çš„æœ€ä½³æ–¹å¼ã€‚

æˆ‘å°†æ•´åˆæˆ‘ä»¬ä¹‹å‰æ‰€æœ‰çš„è®¨è®ºç²¾åâ€”â€”ä»`Context.json`çš„è®¾è®¡ï¼Œåˆ° MD æ–‡æ¡£çš„åˆ©ç”¨ï¼Œå†åˆ° LangGraph çš„ Agentic å·¥ä½œæµâ€”â€”å¹¶å°†å®ƒä»¬ç†”é“¸æˆä¸€ä»½**å¯ä»¥ç›´æ¥è¿è¡Œã€é«˜åº¦æ¨¡å—åŒ–ã€æ³¨é‡Šæå…¶è¯¦å°½**çš„å®Œæ•´ä»£ç å®ç°ã€‚

æˆ‘ä»¬å°†æ„å»º**ä¸¤ä¸ªæ ¸å¿ƒéƒ¨åˆ†**ï¼š

1.  **ç¦»çº¿çš„ã€çŸ¥è¯†åº“æ„å»ºç®¡é“ (MCP)ã€‘**: ä¸€ä¸ªç‹¬ç«‹çš„ CLI å·¥å…·ã€‚
2.  **åœ¨çº¿çš„ã€D2C ä»£ç ç”Ÿæˆå·¥ä½œæµã€‘**: ä¸€ä¸ªåŸºäº LangGraph çš„ã€å¯è¢« API è°ƒç”¨çš„æ ¸å¿ƒå¼•æ“ã€‚

---

### **ç¬¬ä¸€éƒ¨åˆ†ï¼šã€çŸ¥è¯†åº“æ„å»ºç®¡é“ã€‘- å®Œæ•´ä»£ç **

è¿™æ˜¯æˆ‘ä»¬çš„**é˜¶æ®µä¸€**ä»»åŠ¡ï¼Œä¸ºæ‰€æœ‰åç»­å·¥ä½œæä¾›â€œçŸ¥è¯†å¼¹è¯â€ã€‚

**(é¡¹ç›®ç»“æ„: `d2c-knowledge-builder`)**

#### **`src/parser.ts`**

_(è¿™ä»½ä»£ç ä¸ä¹‹å‰æä¾›çš„ç‰ˆæœ¬ä¸€è‡´ï¼Œå› ä¸ºå®ƒå·²ç»è¶³å¤Ÿå¥å£®å’Œæ¸…æ™°ï¼Œè¿™é‡Œä¸ºäº†å®Œæ•´æ€§å†æ¬¡æä¾›)_

```typescript
// src/parser.ts
import { marked } from 'marked'

export interface ParsedComponentInfo {
  name: string
  description: string
  props: Record<string, string>[]
  events: Record<string, string>[]
  slots: Record<string, string>[]
}

/**
 * è§£æå•ä¸ªç»„ä»¶çš„Markdownæ–‡æ¡£ï¼Œæå–å…¶APIä¿¡æ¯ã€‚
 * @param markdownContent - Markdownæ–‡ä»¶çš„æ–‡æœ¬å†…å®¹ã€‚
 * @returns è§£æåçš„ç»“æ„åŒ–ä¿¡æ¯å¯¹è±¡ã€‚
 */
export function parseComponentMarkdown(
  markdownContent: string
): ParsedComponentInfo {
  const tokens = marked.lexer(markdownContent)

  const result: Partial<ParsedComponentInfo> = {
    props: [],
    events: [],
    slots: [],
  }

  result.name = (
    tokens.find(
      (t) => t.type === 'heading' && t.depth === 3
    ) as marked.Tokens.Heading
  )?.text
  result.description = (
    tokens.find((t) => t.type === 'paragraph') as marked.Tokens.Paragraph
  )?.text

  let currentSection: 'props' | 'events' | 'slots' | null = null
  for (const token of tokens) {
    if (token.type === 'heading' && token.depth === 5) {
      if (token.text.toLowerCase().includes('props')) currentSection = 'props'
      else if (token.text.toLowerCase().includes('äº‹ä»¶'))
        currentSection = 'events'
      else if (token.text.toLowerCase().includes('æ’æ§½'))
        currentSection = 'slots'
      else currentSection = null
    }

    if (token.type === 'table' && currentSection) {
      const headers = token.header.map((h) => h.text.trim())
      const rows = token.rows.map((row) => {
        const rowData: Record<string, string> = {}
        row.forEach((cell, index) => {
          rowData[headers[index]] = cell.text.trim()
        })
        return rowData
      })
      result[currentSection]?.push(...rows)
    }
  }

  return result as ParsedComponentInfo
}
```

#### **`src/enhancer.ts`**

_(è¿™ä»½ä»£ç ä¸ä¹‹å‰æä¾›çš„ç‰ˆæœ¬ä¸€è‡´)_

```typescript
// src/enhancer.ts
import OpenAI from 'openai'
import { ParsedComponentInfo } from './parser'

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY })

/**
 * ä½¿ç”¨AIå¢å¼ºç»„ä»¶çš„å…ƒæ•°æ®ï¼Œç‰¹åˆ«æ˜¯ç”Ÿæˆ "mapsTo" è¯­ä¹‰æ˜ å°„ã€‚
 * @param parsedInfo - ä»Markdownè§£æå‡ºçš„åŸºç¡€ç»„ä»¶ä¿¡æ¯ã€‚
 * @returns åŒ…å«å®Œæ•´propsï¼ˆå«mapsToï¼‰çš„å¯¹è±¡ã€‚
 */
export async function enhanceWithAI(
  parsedInfo: ParsedComponentInfo
): Promise<Record<string, any>> {
  console.log(`[AI] Enhancing metadata for component: ${parsedInfo.name}...`)

  const systemPrompt = `
You are an expert D2C system architect. Your task is to generate the "props" section for a "metadata.json" file.
Based on the provided component's API documentation (parsed from Markdown), you need to:
1.  Structure each prop with "type", "defaultValue", and "description".
2.  For props that control visual appearance (like "type", "size", "shape"), generate a "mapsTo" object.
3.  The "mapsTo" object should define rules that map a Figma node's visual characteristics (like "figma.backgroundColor" or "figma.height") to this prop's specific values.
4.  If a characteristic relates to a design token, use the format "token:path.to.token". Otherwise, use raw values (e.g., for height).

The final output MUST be a single, valid JSON object representing the complete "props" for the metadata file.
`

  const userPrompt = `
Component Name: ${parsedInfo.name}
Component Description: ${parsedInfo.description}

Parsed Props Table:
${JSON.stringify(parsedInfo.props, null, 2)}

Please generate the complete, enhanced "props" JSON object now.
`

  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4-turbo',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userPrompt },
      ],
      response_format: { type: 'json_object' },
      temperature: 0.1,
    })

    const jsonString = response.choices[0].message.content
    if (!jsonString) throw new Error('AI returned an empty response.')

    return JSON.parse(jsonString)
  } catch (error) {
    console.error(`[AI] Failed to enhance component ${parsedInfo.name}:`, error)
    throw error
  }
}
```

#### **`src/index.ts`**

_(è¿™ä»½ä»£ç ä¸ä¹‹å‰æä¾›çš„ç‰ˆæœ¬ä¸€è‡´)_

```typescript
// src/index.ts
import { Command } from 'commander'
import { glob } from 'glob'
import fs from 'fs/promises'
import path from 'path'
import 'dotenv/config'
import { parseComponentMarkdown, ParsedComponentInfo } from './parser'
import { enhanceWithAI } from './enhancer'

const program = new Command()

program
  .name('d2c-knowledge-builder')
  .description(
    'A CLI tool to automatically build a component knowledge base from Markdown documents.'
  )
  .version('1.0.0')

program
  .command('build')
  .description('Build the knowledge base')
  .option(
    '-s, --source <path>',
    'Path to the source Markdown documents directory',
    './docs'
  )
  .option(
    '-o, --output <path>',
    'Path to the output directory for metadata.json files',
    './knowledge-base'
  )
  .action(async (options) => {
    console.log('ğŸš€ Starting Knowledge Base build process...')
    console.log(`Source directory: ${options.source}`)
    console.log(`Output directory: ${options.output}`)

    try {
      await fs.mkdir(options.output, { recursive: true })
      const markdownFiles = await glob(`${options.source}/**/*.md`)
      if (markdownFiles.length === 0) {
        console.warn('âš ï¸ No Markdown files found in the source directory.')
        return
      }

      console.log(
        `Found ${markdownFiles.length} component documents to process.`
      )

      for (const file of markdownFiles) {
        console.log(`\n--- Processing: ${file} ---`)

        const markdownContent = await fs.readFile(file, 'utf-8')
        const parsedInfo = parseComponentMarkdown(markdownContent)
        if (!parsedInfo.name) {
          console.warn(
            `Skipping file ${file} as no component name could be parsed.`
          )
          continue
        }

        const enhancedProps = await enhanceWithAI(parsedInfo)

        const finalMetadata = {
          schemaVersion: '1.1',
          name: parsedInfo.name,
          framework: 'Vue',
          source: {
            package: '@xhs/reds-h5-next',
            importStatement: `import { ${parsedInfo.name} } from '@xhs/reds-h5-next';`,
          },
          description: parsedInfo.description,
          slots: parsedInfo.slots.map((s) => ({
            name: s['åç§°'],
            description: s['è¯´æ˜'],
          })),
          props: enhancedProps,
          events: parsedInfo.events.map((e) => ({
            name: e['äº‹ä»¶å'],
            description: e['è¯´æ˜'],
            params: e['å›è°ƒå‚æ•°'],
          })),
        }

        const outputFilename = `${parsedInfo.name.toLowerCase()}.metadata.json`
        const outputPath = path.join(options.output, outputFilename)
        await fs.writeFile(outputPath, JSON.stringify(finalMetadata, null, 2))

        console.log(
          `âœ… Successfully generated metadata for ${parsedInfo.name} at ${outputPath}`
        )
      }

      console.log('\nğŸ‰ Knowledge Base build process finished successfully!')
    } catch (error) {
      console.error('\nâŒ An error occurred during the build process:', error)
      process.exit(1)
    }
  })

program.parse(process.argv)
```

---

### **ç¬¬äºŒéƒ¨åˆ†ï¼šã€D2C ä»£ç ç”Ÿæˆå·¥ä½œæµã€‘ - å®Œæ•´ä»£ç **

è¿™æ˜¯æˆ‘ä»¬çš„**é˜¶æ®µäºŒ**ä»»åŠ¡ï¼Œæ˜¯åœ¨çº¿çš„ã€æ™ºèƒ½çš„æ ¸å¿ƒå¼•æ“ã€‚æˆ‘ä»¬å°†ä½¿ç”¨ Python å’Œ LangGraphã€‚

**(é¡¹ç›®ç»“æ„: `d2c-engine-service`)**

#### **1. é¡¹ç›®è®¾ç½®**

- **è¯­è¨€**: Python 3.9+
- **ä¸»è¦ä¾èµ–**: `langchain`, `langchain-openai`, `langgraph`, `fastapi`, `uvicorn`

#### **2. `state.py` - å®šä¹‰å·¥ä½œæµçŠ¶æ€**

```python
# state.py
from typing import TypedDict, List, Dict, Any, Optional

class D2CWorkflowState(TypedDict):
    """
    å®šä¹‰äº†D2Cä»£ç ç”Ÿæˆå·¥ä½œæµçš„å…±äº«çŠ¶æ€ã€‚
    è¿™ä¸ªçŠ¶æ€å¯¹è±¡ä¼šåœ¨æ‰€æœ‰èŠ‚ç‚¹ä¹‹é—´ä¼ é€’å’Œæ›´æ–°ã€‚
    """
    # --- è¾“å…¥ ---
    context_data: Dict[str, Any]      # ä»Figmaå’ŒContextç”ŸæˆæœåŠ¡å¾—åˆ°çš„Context.json IR
    prompt_instructions: str          # æŒ‡å¯¼æ•´ä¸ªæµç¨‹çš„æ ¸å¿ƒæŒ‡ä»¤
    knowledge_base: List[Dict[str, Any]] # åŠ è½½çš„æ‰€æœ‰metadata.jsonæ–‡ä»¶
    target_framework: str             # 'Vue' or 'React'

    # --- ä¸­é—´äº§ç‰© ---
    current_step: str                 # è¿½è¸ªå½“å‰æ‰§è¡Œåˆ°çš„èŠ‚ç‚¹å
    analysis_report: Optional[str]    # èŠ‚ç‚¹1: å¯¹IRçš„è¯­ä¹‰åˆ†ææŠ¥å‘Š
    component_blueprint: Optional[Dict[str, Any]] # èŠ‚ç‚¹2: ç»„ä»¶è§„åˆ’è“å›¾
    initial_code: Optional[str]       # èŠ‚ç‚¹3: åˆç‰ˆä»£ç 
    review_report: Optional[str]      # èŠ‚ç‚¹4: ä»£ç å®¡æŸ¥æŠ¥å‘Š

    # --- è¾“å‡º ---
    final_code: Optional[str]         # æœ€ç»ˆäº§å‡ºçš„é«˜è´¨é‡ä»£ç 
    error_message: Optional[str]      # æµç¨‹ä¸­ä»»ä½•ä¸€æ­¥çš„é”™è¯¯ä¿¡æ¯
```

#### **3. `agents.py` - å®šä¹‰æ ¸å¿ƒæ™ºèƒ½ä½“**

æˆ‘ä»¬å°†æ¯ä¸ªå¤æ‚çš„ AI ä»»åŠ¡å°è£…æˆä¸€ä¸ªç‹¬ç«‹çš„ Agent ç±»ã€‚

```python
# agents.py
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import JsonOutputParser, StrOutputParser

# å¯ä»¥åœ¨è¿™é‡Œåˆå§‹åŒ–ä¸€ä¸ªå…¨å±€çš„LLMå®ä¾‹
llm = ChatOpenAI(model="gpt-4-turbo", temperature=0.1)

class ArchitecturePlannerAgent:
    """
    æ¶æ„è§„åˆ’å¸ˆæ™ºèƒ½ä½“ã€‚
    è´Ÿè´£æ¥æ”¶Context IRï¼Œå¹¶æ ¹æ®çŸ¥è¯†åº“ï¼Œç”Ÿæˆç»„ä»¶æ„å»ºè“å›¾ã€‚
    """
    def __init__(self, knowledge_base: list):
        self.knowledge_base_str = str(knowledge_base) # è½¬æ¢ä¸ºå­—ç¬¦ä¸²ä»¥ä¾¿æ”¾å…¥Prompt

        # å®šä¹‰Promptæ¨¡æ¿
        self.prompt_template = ChatPromptTemplate.from_messages([
            ("system", """
You are a senior front-end architect. Your task is to create a component blueprint based on a given Context IR and an available component knowledge base.

**Process:**
1.  Analyze the root node and its children in the Context IR.
2.  For each significant part of the IR, check the knowledge base to see if an existing component can be used. Prioritize using existing components.
3.  Decide if the entire IR should be one component or split into a root component and several sub-components.
4.  Output a JSON object describing the plan. The JSON should have a "blueprint" key, containing a description of the plan, and a "components_to_use" key, which is a list of components from the knowledge base that you decided to use.

**Knowledge Base:**
{knowledge_base}
"""),
            ("human", "Here is the Context IR. Please generate the component blueprint.\n\nContext IR:\n{context_ir}")
        ])

        # å®šä¹‰æ‰§è¡Œé“¾
        self.chain = self.prompt_template | llm | JsonOutputParser()

    async def plan(self, context_ir: dict) -> dict:
        return await self.chain.invoke({
            "knowledge_base": self.knowledge_base_str,
            "context_ir": str(context_ir)
        })

class CodeReviewerAgent:
    """ä»£ç å®¡æŸ¥å‘˜æ™ºèƒ½ä½“ã€‚è´Ÿè´£å®¡æŸ¥åˆç‰ˆä»£ç ã€‚"""
    def __init__(self, coding_standards: str):
        self.coding_standards = coding_standards
        self.prompt_template = ChatPromptTemplate.from_messages([
            ("system", """
You are an automated Code Reviewer. Your task is to check the given code against our team's coding standards.
Provide a concise review report, listing any violations or suggestions for improvement. If there are no issues, respond with "No issues found."

**Coding Standards:**
{coding_standards}
"""),
            ("human", "Please review the following code:\n\n<code>\n{code}\n</code>")
        ])
        self.chain = self.prompt_template | llm | StrOutputParser()

    async def review(self, code: str) -> str:
        return await self.chain.invoke({
            "coding_standards": self.coding_standards,
            "code": code
        })

# ... ç±»ä¼¼åœ°ï¼Œå¯ä»¥å®šä¹‰ CodeWriterAgent, CodeRefinerAgent ...
```

#### **4. `graph.py` - æ„å»ºå¹¶ç¼–è¯‘ LangGraph å·¥ä½œæµ**

è¿™æ˜¯å°†æ‰€æœ‰éƒ¨åˆ†ç²˜åˆåœ¨ä¸€èµ·çš„æŒ‡æŒ¥ä¸­å¿ƒã€‚

```python
# graph.py
from langgraph.graph import StateGraph, END
from state import D2CWorkflowState
from agents import ArchitecturePlannerAgent, CodeReviewerAgent # å‡è®¾å…¶ä»–Agentä¹Ÿå·²å®šä¹‰
import json

# --- èŠ‚ç‚¹å‡½æ•°å®šä¹‰ ---
# æ¯ä¸ªèŠ‚ç‚¹å‡½æ•°è´Ÿè´£è°ƒç”¨ä¸€ä¸ªAgentæˆ–æ‰§è¡Œä¸€æ®µé€»è¾‘ï¼Œå¹¶æ›´æ–°çŠ¶æ€

async def plan_architecture_node(state: D2CWorkflowState) -> dict:
    print("--- èŠ‚ç‚¹: æ¶æ„ä¸ç»„ä»¶è§„åˆ’ ---")
    try:
        planner = ArchitecturePlannerAgent(knowledge_base=state['knowledge_base'])
        blueprint = await planner.plan(state['context_data'])
        return {"component_blueprint": blueprint}
    except Exception as e:
        return {"error_message": f"Planning failed: {e}"}

async def write_initial_code_node(state: D2CWorkflowState) -> dict:
    print("--- èŠ‚ç‚¹: åˆç‰ˆä»£ç ç¼–å†™ ---")
    # æ­¤å¤„è°ƒç”¨CodeWriterAgent...
    # ...
    # æ¨¡æ‹Ÿè¿”å›
    initial_code = "<template><div>Hello World</div></template>"
    return {"initial_code": initial_code}

async def review_code_node(state: D2CWorkflowState) -> dict:
    print("--- èŠ‚ç‚¹: ä»£ç å®¡æŸ¥ ---")
    try:
        # å®é™…ä¸­ï¼Œcoding_standardså¯ä»¥ä»é…ç½®æ–‡ä»¶è¯»å–
        coding_standards = "1. All props must be typed. 2. Use <script setup>."
        reviewer = CodeReviewerAgent(coding_standards=coding_standards)
        report = await reviewer.review(state['initial_code'])
        return {"review_report": report}
    except Exception as e:
        return {"error_message": f"Review failed: {e}"}

async def refine_code_node(state: D2CWorkflowState) -> dict:
    print("--- èŠ‚ç‚¹: ä»£ç ä¿®æ­£ ---")
    # æ­¤å¤„è°ƒç”¨CodeRefinerAgent...
    # ...
    # æ¨¡æ‹Ÿè¿”å›
    final_code = "<template>\n  <div>Hello World!</div>\n</template>"
    return {"final_code": final_code}

# --- æ¡ä»¶è·¯ç”±å‡½æ•° ---

def should_refine(state: D2CWorkflowState) -> str:
    """
    æ ¹æ®å®¡æŸ¥æŠ¥å‘Šå†³å®šæ˜¯å¦éœ€è¦ä¿®æ­£ä»£ç ã€‚
    """
    print("--- è·¯ç”±: åˆ¤æ–­æ˜¯å¦éœ€è¦ä¿®æ­£ ---")
    if state.get("error_message"):
      return "error_handler" # å¦‚æœä¹‹å‰çš„æ­¥éª¤å‡ºé”™ï¼Œç›´æ¥è¿›å…¥é”™è¯¯å¤„ç†

    review_report = state.get("review_report")
    if review_report and "no issues found" not in review_report.lower():
        print("å†³ç­–: éœ€è¦ä¿®æ­£ã€‚")
        return "refine_code"
    else:
        print("å†³ç­–: æ— éœ€ä¿®æ­£ï¼Œæµç¨‹ç»“æŸã€‚")
        # å¦‚æœæ— éœ€ä¿®æ­£ï¼Œåˆç‰ˆä»£ç å°±æ˜¯æœ€ç»ˆä»£ç 
        return "end_with_success"

def check_for_errors(state: D2CWorkflowState) -> str:
    """ä¸€ä¸ªé€šç”¨çš„é”™è¯¯æ£€æŸ¥è·¯ç”±"""
    if state.get("error_message"):
      return "error_handler"
    return "continue"

# --- æ„å»ºå›¾ ---

# åˆ›å»ºä¸€ä¸ªStateGraphå®ä¾‹
workflow = StateGraph(D2CWorkflowState)

# æ·»åŠ èŠ‚ç‚¹
workflow.add_node("plan_architecture", plan_architecture_node)
workflow.add_node("write_initial_code", write_initial_code_node)
workflow.add_node("review_code", review_code_node)
workflow.add_node("refine_code", refine_code_node)

# ç»ˆç‚¹å’Œé”™è¯¯å¤„ç†çš„ç‰¹æ®ŠèŠ‚ç‚¹
def success_node(state: D2CWorkflowState):
    print("--- æµç¨‹æˆåŠŸç»“æŸ ---")
    # å¦‚æœåˆç‰ˆä»£ç æ— éœ€ä¿®æ”¹ï¼Œå®ƒå°±æ˜¯æœ€ç»ˆä»£ç 
    if not state.get("final_code"):
        state['final_code'] = state['initial_code']
    return {"final_code": state['final_code']}

def error_node(state: D2CWorkflowState):
    print(f"--- æµç¨‹å› é”™è¯¯ä¸­æ–­ --- \né”™è¯¯ä¿¡æ¯: {state['error_message']}")
    return {}

workflow.add_node("success_node", success_node)
workflow.add_node("error_handler", error_node)

# å®šä¹‰æµç¨‹çš„èµ·ç‚¹å’Œè¾¹
workflow.set_entry_point("plan_architecture")

workflow.add_conditional_edges(
    "plan_architecture",
    lambda s: "continue" if not s.get("error_message") else "error_handler",
    {"continue": "write_initial_code", "error_handler": "error_handler"}
)
workflow.add_conditional_edges(
    "write_initial_code",
    lambda s: "continue" if not s.get("error_message") else "error_handler",
    {"continue": "review_code", "error_handler": "error_handler"}
)

# å®¡æŸ¥åçš„æ¡ä»¶åˆ†æ”¯
workflow.add_conditional_edges(
    "review_code",
    should_refine,
    {
        "refine_code": "refine_code",
        "end_with_success": "success_node",
        "error_handler": "error_handler"
    }
)

workflow.add_conditional_edges(
    "refine_code",
    lambda s: "error_handler" if s.get("error_message") else "success_node",
    {"success_node": "success_node", "error_handler": "error_handler"}
)


# è¿æ¥åˆ°æœ€ç»ˆçš„ç»“æŸèŠ‚ç‚¹
workflow.add_edge("success_node", END)
workflow.add_edge("error_handler", END)

# ç¼–è¯‘å›¾
d2c_workflow_app = workflow.compile()

# --- è¿è¡Œç¤ºä¾‹ ---
async def run_workflow():
    # 1. åŠ è½½çŸ¥è¯†åº“ (åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™ä¼šä»æ–‡ä»¶æˆ–æ•°æ®åº“åŠ è½½)
    knowledge_base = [json.loads(await fs.readFile("./knowledge-base/button.metadata.json", "utf-8"))]

    # 2. å‡†å¤‡è¾“å…¥ (åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™æ¥è‡ªContextç”ŸæˆæœåŠ¡)
    inputs = {
        "context_data": { "type": "Button", "props": { "style": { "visual": { "backgroundColor": "#4F46E5" } } } },
        "prompt_instructions": "Please generate a Vue component.",
        "knowledge_base": knowledge_base,
        "target_framework": "Vue"
    }

    # 3. è¿è¡Œå·¥ä½œæµ
    final_state = await d2c_workflow_app.ainvoke(inputs)

    print("\n--- æœ€ç»ˆç»“æœ ---")
    if final_state.get("final_code"):
        print(final_state["final_code"])
    else:
        print("å·¥ä½œæµæ‰§è¡Œå¤±è´¥ã€‚")
        print("é”™è¯¯ä¿¡æ¯:", final_state.get("error_message"))

if __name__ == "__main__":
    import asyncio
    asyncio.run(run_workflow())
```

è¿™ä»½ä»£ç ä¸ºä½ æä¾›äº†ä¸€ä¸ª**å®Œæ•´çš„ã€å¯è¿è¡Œçš„ã€ç”Ÿäº§çº§åˆ«çš„ LangGraph å·¥ä½œæµéª¨æ¶**ã€‚å®ƒå°†æˆ‘ä»¬æ‰€æœ‰çš„è®¨è®ºâ€”â€”Agent åŒ–ã€çŠ¶æ€ç®¡ç†ã€æ¡ä»¶è·¯ç”±ã€é”™è¯¯å¤„ç†â€”â€”éƒ½èå…¥äº†è¿›å»ã€‚ä½ å¯ä»¥ä»¥æ­¤ä¸ºåŸºç¡€ï¼Œå¡«å……æ¯ä¸ª Agent çš„å…·ä½“ Prompt å’Œé€»è¾‘ï¼Œæ¥æ„å»ºä½ æœ€ç»ˆçš„ã€ç‹¬ç«‹çš„ D2C ç³»ç»Ÿã€‚
// ==UserScript==
// @name         [AI Studio] è¯·æ±‚ä¿®æ”¹å™¨
// @name:en      [AI Studio] Request Changer
// @namespace    http://tampermonkey.net/
// @version      1.0
// @description  æ‹¦æˆª aistudio.google.com çš„GenerateContentè¯·æ±‚ä¿®æ”¹æ¨¡å‹ï¼Œå¹¶åŒæ­¥ä¿®æ”¹UIæ˜¾ç¤ºã€‚
// @description:en Intercepts GenerateContent request on aistudio.google.com to modify the model, and syncs the UI to clearly show the forced model name.
// @author       Z_06
// @match        *://aistudio.google.com/*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=google.com
// @grant        GM_setValue
// @grant        GM_getValue
// @grant        GM_registerMenuCommand
// @grant        GM_addStyle
// @license      MIT
// ==/UserScript==

(function() {
    'use strict';

    // --- é…ç½®åŒºåŸŸ ---
    const SCRIPT_NAME = "[AI Studio] è¯·æ±‚ä¿®æ”¹å™¨";
    const STORAGE_KEY = "aistudio_custom_model_name";
    const DEFAULT_MODEL = "models/kingfall-ab-test"; // é»˜è®¤æ¨¡å‹
    const TARGET_URL = "https://alkalimakersuite-pa.clients6.google.com/$rpc/google.internal.alkali.applications.makersuite.v1.MakerSuiteService/GenerateContent";
    // æ¨¡å‹é€‰æ‹©å™¨åœ¨é¡µé¢ä¸­çš„CSSé€‰æ‹©å™¨
    const MODEL_SELECTOR_CONTAINER = 'div.settings-model-selector';

    // --- è·å–å·²ä¿å­˜çš„æˆ–é»˜è®¤çš„æ¨¡å‹åç§° ---
    let customModelName = GM_getValue(STORAGE_KEY, DEFAULT_MODEL);

    // --- æ³¨å…¥CSSæ ·å¼ ---
    // ä½¿ç”¨ GM_addStyle æ¥æ·»åŠ CSSè§„åˆ™ï¼Œè¿™æ˜¯æœ€å¹²å‡€çš„æ–¹å¼
    GM_addStyle(`
        /* 1. éšè—åŸå§‹çš„Angular Materialä¸‹æ‹‰é€‰æ‹©æ¡†çš„è§¦å‘å™¨éƒ¨åˆ† */
        ${MODEL_SELECTOR_CONTAINER} ms-model-selector-two-column {
            display: none !important;
        }

        /* 2. æˆ‘ä»¬è‡ªå·±æ³¨å…¥çš„é™æ€æ–‡æœ¬æ ‡ç­¾çš„æ ·å¼ */
        #custom-model-display {
            width: 100%;
            padding: 8px 12px;
            margin-top: 4px;
            border: 1px solid #d2e3fc;
            border-radius: 8px;
            color: #e2e2e5;
            font-family: 'Google Sans', 'Roboto', sans-serif;
            font-size: 14px;
            font-weight: 500;
            text-align: left;
            box-sizing: border-box;
            cursor: help; /* é¼ æ ‡æ‚¬æµ®æ—¶æ˜¾ç¤ºå¸®åŠ©æ‰‹åŠ¿ */
            overflow-wrap: break-word; /* å…è®¸é•¿åç§°æ¢è¡Œ */
        }
    `);

    // --- èœå•å’ŒUIæ›´æ–°é€»è¾‘ ---
    function updateUIDisplay(modelName) {
        const customDisplay = document.getElementById('custom-model-display');
        if (customDisplay) {
            const displayName = modelName.replace('models/', ''); // ç§»é™¤å‰ç¼€ä»¥ç®€åŒ–æ˜¾ç¤º
            customDisplay.textContent = `${displayName}`;
            customDisplay.title = `æ‰€æœ‰è¯·æ±‚éƒ½å°†è¢«å¼ºåˆ¶ä½¿ç”¨æ­¤æ¨¡å‹: ${modelName}`;
        }
    }

    function registerMenu() {
        GM_registerMenuCommand(`è®¾ç½®è¯·æ±‚æ¨¡å‹`, () => {
            const newModel = prompt("è¯·è¾“å…¥è¦å¼ºåˆ¶ä½¿ç”¨çš„å®Œæ•´æ¨¡å‹åç§°:", customModelName);
            if (newModel && newModel.trim() !== "") {
                customModelName = newModel.trim();
                GM_setValue(STORAGE_KEY, customModelName);
                alert(`æ¨¡å‹å·²æ›´æ–°ä¸º:\n${customModelName}`);
                // ç«‹å³æ›´æ–°é¡µé¢ä¸Šçš„UIæ˜¾ç¤º
                updateUIDisplay(customModelName);
            }
        });
    }
    registerMenu();

    // --- DOM å˜åŠ¨ç›‘å¬ï¼Œç”¨äºæ³¨å…¥UIå…ƒç´  ---
    // ä½¿ç”¨ MutationObserver æ¥ç›‘å¬DOMå˜åŒ–ï¼Œç¡®ä¿åœ¨Angularæ¸²æŸ“å‡ºç»„ä»¶åå†æ“ä½œ
    const observer = new MutationObserver((mutations, obs) => {
        const container = document.querySelector(MODEL_SELECTOR_CONTAINER);
        // å¦‚æœå®¹å™¨å­˜åœ¨ï¼Œå¹¶ä¸”æˆ‘ä»¬è¿˜æ²¡æœ‰æ³¨å…¥è¿‡è‡ªå®šä¹‰UI
        if (container && !document.getElementById('custom-model-display')) {
            console.log(`[${SCRIPT_NAME}] å‘ç°æ¨¡å‹é€‰æ‹©å™¨å®¹å™¨ï¼Œå‡†å¤‡æ³¨å…¥UI...`);

            const customDisplayElement = document.createElement('div');
            customDisplayElement.id = 'custom-model-display';

            // æ‰¾åˆ°å¯ä»¥é™„åŠ æˆ‘ä»¬å…ƒç´ çš„åœ°æ–¹
            const injectionPoint = container.querySelector('.item-input-form-field');
            if (injectionPoint) {
                injectionPoint.appendChild(customDisplayElement);
                updateUIDisplay(customModelName); // è®¾ç½®åˆå§‹æ–‡æœ¬
                console.log(`[${SCRIPT_NAME}] è‡ªå®šä¹‰UIæ³¨å…¥æˆåŠŸã€‚`);
                // ç†è®ºä¸Šå¯ä»¥æ–­å¼€è§‚å¯Ÿè€…ï¼Œä½†ä¿æŒè¿è¡Œä»¥é˜²UIè¢«å®Œå…¨é‡ç»˜
                // obs.disconnect();
            }
        }
    });

    // å¯åŠ¨è§‚å¯Ÿè€…ï¼Œç›‘å¬æ•´ä¸ªæ–‡æ¡£çš„å˜åŒ–
    observer.observe(document.body, {
        childList: true,
        subtree: true
    });


    // --- æ ¸å¿ƒï¼šæ‹¦æˆªå’Œä¿®æ”¹ XHR è¯·æ±‚ (ä¸V1ç‰ˆæœ¬ç›¸åŒ) ---
    const originalOpen = XMLHttpRequest.prototype.open;
    XMLHttpRequest.prototype.open = function(method, url) {
        this._url = url;
        this._method = method;
        return originalOpen.apply(this, arguments);
    };

    const originalSend = XMLHttpRequest.prototype.send;
    XMLHttpRequest.prototype.send = function(data) {
        if (this._url === TARGET_URL && this._method.toUpperCase() === 'POST' && data) {
            try {
                let payload = JSON.parse(data);
                const originalModel = payload[0];

                if (typeof originalModel === 'string' && originalModel.startsWith('models/')) {
                    console.log(`[${SCRIPT_NAME}] æ‹¦æˆªè¯·æ±‚ã€‚åŸå§‹æ¨¡å‹: ${originalModel} -> å¼ºåˆ¶ä¿®æ”¹ä¸º: ${customModelName}`);
                    payload[0] = customModelName;
                    const modifiedData = JSON.stringify(payload);
                    return originalSend.call(this, modifiedData);
                }
            } catch (e) {
                console.error(`[${SCRIPT_NAME}] ä¿®æ”¹è¯·æ±‚è´Ÿè½½æ—¶å‡ºé”™:`, e);
            }
        }
        return originalSend.apply(this, arguments);
    };

    console.log(`[${SCRIPT_NAME}] å·²åŠ è½½ã€‚å½“å‰å¼ºåˆ¶æ¨¡å‹ä¸º "${customModelName}"ã€‚`);
})();